# Transportation and Logistics SQL Challenge

Industry: Transportation and Logistics

Business Context: A logistics company manages a fleet of delivery vehicles. 
Your task is to analyze delivery efficiency, vehicle utilization, and overall performance to provide actionable insights for optimizing operations.

## ðŸ“‚ **Dataset Overview**

### **Tables**
1. **Fleet**: Details about vehicles in the fleet.
2. **Deliveries**: Data about individual delivery jobs, including distance, time, and delivery status.
3. **Drivers**: Information about the drivers responsible for deliveries.

---

## ðŸ“ **Challenges and Solutions**
## Table of Contents
1. [Challenge 1: Revenue by Vehicle Type](#challenge-1-revenue-by-vehicle-type)
2. [Challenge 2: Completed Deliveries by Driver](#challenge-2-completed-deliveries-by-driver)
3. [Challenge 3: Average Delivery Time by Vehicle Type](#challenge-3-average-delivery-time-by-vehicle-type)
4. [Challenge 4: Weekly Revenue by Driver](#challenge-4-weekly-revenue-by-driver)
5. [Challenge 5: Revenue Per Mile](#challenge-5-revenue-per-mile)
6. [Challenge 6: Delivery Completion Rates](#challenge-6-delivery-completion-rates)

## Challenge 1: Revenue by Vehicle Type
### Identify the total revenue generated by each vehicle type for completed deliveries in February 2023.
### Expected Output:
1. VehicleType
2. TotalRevenue
### Query Walkthrough
1. Use the `logistics.fleet` and `logistics.deliveries` tables.
2. Join these tables on `VehicleID`.
3. Filter for deliveries in February 2023 (`DeliveryDate` between '2023-02-01' and '2023-03-01').
4. Group data by `VehicleType` and calculate total revenue using `SUM(Revenue)`.
### Solution
```sql
SELECT  F.VehicleType
        ,SUM(D.Revenue) as TotalRevenue
FROM logistics.fleet f LEFT JOIN logistics.deliveries d ON f.VehicleID = d.VehicleID
AND d.DeliveryDate >= '2023-02-01' AND d.DeliveryDate < '2023-03-01'
group by F.VehicleType
order by TotalRevenue desc;
```

## Challenge 2: Completed Deliveries by Driver
### Determine the top 3 drivers with the highest number of completed deliveries.
### Expected Output:
1. DriverName
2. TotalDeliveries
### Query Walkthrough
1. Use the `logistics.fleet` and `logistics.deliveries` tables.
2. Join these tables on `VehicleID`.
3. Filter for deliveries in February 2023 (`DeliveryDate` between '2023-02-01' and '2023-03-01').
4. Group data by `VehicleType` and calculate total revenue using `SUM(Revenue)`.
### Solution
```sql
-- look at intermediate data
SELECT  dr.FirstName + ' ' + dr.LastName as driver_Name
        ,de.DeliveryDate
        ,de.Status
        ,de.Distance
        ,de.DeliveryTime
        ,de.Revenue
FROM logistics.drivers dr LEFT JOIN logistics.deliveries de ON dr.DriverID+100 = de.DriverID -- driverid in deliveries tables start with 100
WHERE de.Status = 'Completed';

-- final query
SELECT  top 3
         dr.FirstName + ' ' + dr.LastName as DriverName
        ,count(de.DeliveryDate) as TotalDeliveries
FROM logistics.drivers dr LEFT JOIN logistics.deliveries de ON dr.DriverID+100 = de.DriverID -- driverid in deliveries tables start with 100
WHERE de.Status = 'Completed'
group by dr.FirstName + ' ' + dr.LastName
order by TotalDeliveries desc;
```

## Challenge 3: Average Delivery Time by Vehicle Type
### Calculate the average delivery time for each vehicle type. For vehicles with zero deliveries, ensure they still appear in the result with NULL as the average delivery time.
### Expected Output:
1. VehicleType
2. AverageDeliveryTime
### Query Walkthrough
First thing is we'd need to look at the list of distinct vehicles types from the fleet table. Second thing we'd need is the deliveries made with these vehicle types for which we'd need to join the 2 tables using VehicleID column. Then we can group the data by VehicleType when calculating the Avg DeliveryTime in hours.
### Solution
```sql
-- look at intermediate data
SELECT  f.VehicleID
        ,f.VehicleType
        ,d.*
FROM logistics.fleet f LEFT JOIN logistics.deliveries d ON f.VehicleID=d.VehicleID;

-- final query
SELECT  f.VehicleType
        ,cast(avg(d.DeliveryTime) as decimal(4,2)) as Avg_DeliveryTime_Hours
FROM logistics.fleet f LEFT JOIN logistics.deliveries d ON f.VehicleID=d.VehicleID
group by f.VehicleType
order by Avg_DeliveryTime_Hours
```

## Challenge 4: Weekly Revenue by Driver
### Using window functions, identify the driver with the highest cumulative revenue each week in February 2023.
### Expected Output:
1. WeekStartDate
2. DriverName
3. CumulativeRevenue
### Query Walkthrough
For this question it seems we can get all the required data from logistics.deliveries table. Challenge is to calculate total revenue with data granularity set at a weekly level grouped by driver name. We need to find the Week start date for the delivery date, and for this we will use the datepart func()

        In the below example '2023-02-14' is the 3rd day of the week, 
        Let's see how the entire function result pans out:
        = DATEADD(dd, -(DATEPART(dw, '2023-02-14')-1), '2023-02-14')
        = DATEADD(dd, -(3-1), '2023-02-14')
        = DATEADD(dd, -2, '2023-02-14')
        = '2023-02-12' -- start of the week
### Solution
```sql
-- intermediate data to visualize how week start date is calculated
SELECT  d.DeliveryDate
        ,DATENAME(dw, d.DeliveryDate) as day_name_of_week
        ,DATEPART(dw, d.DeliveryDate) as day_number_of_week
        ,-(DATEPART(dw, d.DeliveryDate)-1) as value_for_dateadd
        ,DATEADD(dd, -(DATEPART(dw, d.DeliveryDate)-1), d.DeliveryDate) as week_start
        ,dr.FirstName + ' ' + dr.LastName as driver_name
        ,d.Revenue
FROM logistics.drivers dr LEFT JOIN logistics.deliveries d ON dr.DriverID+100 = d.DriverID 
order by d.DeliveryDate,driver_name;

-- final query
SELECT  DATEADD(dd, -(DATEPART(dw, d.DeliveryDate)-1), d.DeliveryDate) as [WeekStart]
        ,dr.FirstName + ' ' + dr.LastName as driver_Name
        ,sum(d.Revenue) as Revenue
FROM logistics.drivers dr LEFT JOIN logistics.deliveries d ON dr.DriverID+100 = d.DriverID 
GROUP BY DATEADD(dd, -(DATEPART(dw, d.DeliveryDate)-1), d.DeliveryDate),dr.FirstName + ' ' + dr.LastName
order by WeekStart,driver_Name;
```

## Challenge 5: Revenue Per Mile
### Analyze the fleetâ€™s efficiency. For each vehicle, calculate the total distance covered, the revenue generated, and the fuel efficiency impact (Revenue per mile). For bikes, display N/A for the fuel efficiency impact.
### Expected Output:
1. VehicleID
2. TotalDistance
3. TotalRevenue
4. RevenuePerMile
### Query Walkthrough:
We'd need the fleet table to ensure we include even the missing vehicle ids in deliveries table.  Then we join deliveries table to get rest of the columns. Then we use the below calculations to get the aggregates - 
sum(distance), sum(revenue), sum(revenue) / sum(distance)
Then group the data by VehicleID. Finally, we'll use COALESCE to work with Null values, and replace them with 'N/A' wherever applicable
### Solution
```sql
SELECT  f.VehicleID
        ,COALESCE(sum(d.Distance),0) as TotalDistance
        ,COALESCE(sum(d.Revenue),0) as TotalRevenue
        ,COALESCE(cast(sum(d.Revenue)/sum(d.Distance) as VARCHAR),'N/A') as RevenuePerMile
FROM logistics.fleet f left join logistics.deliveries d on f.VehicleID = d.VehicleID
GROUP BY f.VehicleID
ORDER BY f.VehicleID;
```

## Challenge 6: Delivery Completion Rates
### Identify the underperforming drivers who completed less than 50% of their 
total assigned deliveries (including pending and failed ones) in February 2023.
### Expected Output:
1. DriverName
2. TotalAssignedDeliveries
3. CompletedDeliveries
4. CompletionRate
### Query Walkthrough:
For this we'd need the drivers and deliveries tables. In the deliveries table we have a status column with which we can identify completed  deliveries vs assigned deliveries. In the drivers table we'd ask the stake holders whether they need active drivers only.
### Solution
```sql
-- loking at the intermediate data
select  dr.FirstName + ' ' + dr.LastName as driver_Name
        ,de.DeliveryID
        ,de.[Status]
FROM logistics.drivers dr LEFT JOIN logistics.deliveries de ON dr.DriverID+100 = de.DriverID -- driverid in deliveries tables start with 100
where dr.[Status] = 'Active'; -- assumption

select  dr.FirstName + ' ' + dr.LastName as driver_Name
        ,sum(
             case
                when de.[Status] = 'Completed' then 1 
                else 0
             end 
            ) as CompletedDeliveries
        ,count(de.DeliveryID) as TotalAssignedDeliveries        
FROM logistics.drivers dr LEFT JOIN logistics.deliveries de ON dr.DriverID+100 = de.DriverID -- driverid in deliveries tables start with 100
where dr.[Status] = 'Active' -- assumption
group by dr.FirstName + ' ' + dr.LastName;

-- final query 
with cte as 
(
select  dr.FirstName + ' ' + dr.LastName as DriverName
        ,sum(
             case
                when de.[Status] = 'Completed' then 1 
                else 0
             end 
            ) as CompletedDeliveries
        ,count(de.DeliveryID) as TotalAssignedDeliveries  
FROM logistics.drivers dr LEFT JOIN logistics.deliveries de ON dr.DriverID+100 = de.DriverID -- driverid in deliveries tables start with 100
where dr.[Status] = 'Active' -- assumption
group by dr.FirstName + ' ' + dr.LastName
)
select  DriverName
        ,CompletedDeliveries
        ,TotalAssignedDeliveries
        ,cast(100.0*CompletedDeliveries/TotalAssignedDeliveries as decimal(5,2)) as CompletionRate
from cte;
```
